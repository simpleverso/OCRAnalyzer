# -*- coding: utf-8 -*-
"""AnalisisDatosFinancierosv3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u9yKDbupV4QtETTXQIOWTIDVVqVMjW2B
"""

#obtener imagenes
!pip install keyboard
!pip install pyscreenshot
!pip install pyautogui
import pyscreenshot
import keyboard
import time
contador=0
while True:
    try:
        if keyboard.is_pressed('s'):
           image = pyscreenshot.grab(bbox=(85, 240, 820, 600)) #nota se debe validar el tama침o del screenshot
           rgb_im = image.convert('RGB')
           strnombre = temp+str(contador)
           rgb_img.save(strnombre+'.jpg')
           contador++
           time.sleep(1)
           break
        if keyboard.is_pressed('n'):
           image = pyscreenshot.grab(bbox=(85, 240, 820, 600)) #nota se debe validar el tama침o del screenshot
           rgb_im = image.convert('RGB')
           strnombre = temp+str(contador)
           rgb_img.save(strnombre+'.jpg')
           contador++
           time.sleep(1)
           break
        else:
            time.sleep(1)
    except:
        break

#dependencias
!pip install pyscreenshot
!pip install playsound
!pip install tensorflow
!pip install pygame
!pip install pyautogui

#importar paquetes y datos
import pyscreenshot
import tensorflow.keras
from PIL import Image, ImageOps
import numpy as np
import logging
logging.getLogger('tensorflow').disabled = True
import playsound
from pygame import mixer
import numpy as numpy
import time
from datetime import datetime
np.set_printoptions(suppress=True)
import pyautogui

# Lectura de modelo de la red neuronal
model = tensorflow.keras.models.load_model('keras_model.h5')
data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32)

#completo
print(datetime.now().time())
minutoAnt = 0;
minutoNue = 0;
while True:
   #print(datetime.now().time())
   now = datetime.now()
   minutoNue = now.minute
   if minutoAnt == 0:
        minutoAnt = now.minute
   if minutoNue - minutoAnt  == 1 or minutoNue - minutoAnt == -59: #nota el primer minuto no se ejecuta.
        minutoAnt = minutoNue
        #print("nuevo") #print(minutoNue) #print(minutoAnt)
        #aqui es donde se debe ejecutar lo que se debe hacer cada minuto
        
        #tomar screenshot
        # im=pyscreenshot.grab(bbox=(x1,x2,y1,y2))
        image = pyscreenshot.grab(bbox=(85, 240, 820, 600)) #nota se debe validar el tama침o del screenshot
        #image.save("temp.jpg")
        rgb_im = image.convert('RGB')
        rgb_img.save('temp.jpg')
        
        #procesar imagen con red neuronal
        image = Image.open('temp.jpg')
        size = (224, 224)
        image = ImageOps.fit(image, size, Image.ANTIALIAS)
        image_array = np.asarray(image)
        normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1
        data[0] = normalized_image_array
        prediction = model.predict(data)
        #print(prediction)
        a_np = np.array(prediction[0,...])
        resultante = np.argmax(a_np)
        #resultante
        if resultante == 0:
            mixer.init()
            mixer.music.load(r'C:\Users\gsantiago\Desktop\analisis de informacion financiera\sube.mp3')
            pyautogui.moveTo(1300,450) #arriba
            pyautogui.click(1300,450)
            pyautogui.click(1300,350) #neutral
            print("sube")
            mixer.music.play()
        if resultante == 1:
            mixer.init()
            mixer.music.load(r'C:\Users\gsantiago\Desktop\analisis de informacion financiera\baja.mp3')
            pyautogui.moveTo(1300,570) #abajo
            pyautogui.click(1300,570)
            pyautogui.click(1300,350) #neutral
            print("baja")
            mixer.music.play()
        if resultante == 2:
            mixer.init()
            mixer.music.load(r'C:\Users\gsantiago\Desktop\analisis de informacion financiera\igual.mp3')
            pyautogui.moveTo(1300,350) #Neutral
            pyautogui.click(1300,350)
            print("igual")
            mixer.music.play()
   #print(minutoNue)
   time.sleep(1)

#ejecuci칩n del script cada minuto
import time
from datetime import datetime
print(datetime.now().time())
minutoAnt = 0;
minutoNue = 0;
while True:
   #print(datetime.now().time())
   now = datetime.now()
   minutoNue = now.minute
   if minutoAnt == 0:
        minutoAnt = now.minute
   if minutoNue - minutoAnt  == 1 or minutoNue - minutoAnt == -59: #nota el primer minuto no se ejecuta.
        # print("actual") # print(minutoNue) # print(minutoAnt) 
        minutoAnt = minutoNue 
        print("nuevo") # print(minutoNue) # print(minutoAnt) # print("\n")
        #aqui es donde se debe ejecutar lo que se debe hacer cada minuto
            
        #aqui es donde se debe ejecutar lo que se debe hacer cada minuto
   #print(minutoNue)
   time.sleep(1)

#tensorflow Customvision S1
#Install either Python 2.7+ or Python 3.6+.
#Install pip.

import argparse
import pathlib
import numpy as np
import tensorflow
import PIL.Image


class Model:
    def __init__(self, model_filepath):
        self.graph_def = tensorflow.compat.v1.GraphDef()
        self.graph_def.ParseFromString(model_filepath.read_bytes())

        input_names, self.output_names = self._get_graph_inout(self.graph_def)
        assert len(input_names) == 1
        self.input_name = input_names[0]
        self.input_shape = self._get_input_shape(self.graph_def, self.input_name)

    def predict(self, image_filepath):
        image = PIL.Image.open(image_filepath).resize(self.input_shape)
        input_array = np.array(image, dtype=np.float32)[np.newaxis, :, :, :]

        with tensorflow.compat.v1.Session() as sess:
            tensorflow.import_graph_def(self.graph_def, name='')
            out_tensors = [sess.graph.get_tensor_by_name(o + ':0') for o in self.output_names]
            outputs = sess.run(out_tensors, {self.input_name + ':0': input_array})

        return {name: outputs[i] for i, name in enumerate(self.output_names)}

    @staticmethod
    def _get_graph_inout(graph_def):
        input_names = []
        inputs_set = set()
        outputs_set = set()

        for node in graph_def.node:
            if node.op == 'Placeholder':
                input_names.append(node.name)

            for i in node.input:
                inputs_set.add(i.split(':')[0])
            outputs_set.add(node.name)

        output_names = list(outputs_set - inputs_set)
        return input_names, output_names

    @staticmethod
    def _get_input_shape(graph_def, input_name):
        for node in graph_def.node:
            if node.name == input_name:
                return [dim.size for dim in node.attr['shape'].shape.dim][1:3]


def print_outputs(outputs):
    outputs = list(outputs.values())[0]
    for index, score in enumerate(outputs[0]):
        print(f"Label: {index}, score: {score:.5f}")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('model_filepath', type=pathlib.Path)
    parser.add_argument('image_filepath', type=pathlib.Path)

    args = parser.parse_args()

    model = Model(args.model_filepath)
    outputs = model.predict(args.image_filepath)
    print_outputs(outputs)


if __name__ == '__main__':
    main()
